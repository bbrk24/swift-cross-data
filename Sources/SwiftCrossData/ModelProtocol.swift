#if !canImport(CoreData)
    import SQLite
    import Foundation

    public typealias Row = SQLite.Row

    func decodeRowValue(row: Row, columnName: String, type: SqliteTypeName) throws -> SqliteValue {
        switch type {
        case .integer:
            .integer(try row.get(SQLite.Expression<Int64>(columnName)))
        case .real:
            .real(try row.get(SQLite.Expression<Double>(columnName)))
        case .text:
            .text(try row.get(SQLite.Expression<String>(columnName)))
        case .blob:
            .blob(try row.get(SQLite.Expression<Data>(columnName)))
        case .null(let inner):
            switch inner {
            case .integer:
                if let value = try row.get(SQLite.Expression<Int64?>(columnName)) {
                    .integer(value)
                } else {
                    .null
                }
            case .real:
                if let value = try row.get(SQLite.Expression<Double?>(columnName)) {
                    .real(value)
                } else {
                    .null
                }
            case .text:
                if let value = try row.get(SQLite.Expression<String?>(columnName)) {
                    .text(value)
                } else {
                    .null
                }
            case .blob:
                if let value = try row.get(SQLite.Expression<Data?>(columnName)) {
                    .blob(value)
                } else {
                    .null
                }
            case .null(_):
                try decodeRowValue(row: row, columnName: columnName, type: inner)
            }
        }
    }

    public struct DecodingFailed: Error {
        public var type: any ColumnType.Type
        public var value: SqliteValue
    }

    public func decodeRowValue<T: ColumnType>(_ row: Row, _ columnName: String) throws -> T {
        let value = try decodeRowValue(row: row, columnName: columnName, type: T.sqliteTypeName)
        if let decoded = T.decode(sqliteValue: value) {
            return decoded
        } else {
            throw DecodingFailed(type: T.self, value: value)
        }
    }

#endif

public struct ModelProperty<T> {
    let keyPath: PartialKeyPath<T>
    let columnName: String
    let defaultValue: Any?
    let columnType: any ColumnType.Type

    public init<PropertyType: ColumnType>(
        keyPath: WritableKeyPath<T, PropertyType>,
        columnName: String,
        defaultValue: PropertyType? = nil
    ) {
        self.keyPath = keyPath
        self.columnName = columnName
        self.defaultValue = defaultValue
        self.columnType = PropertyType.self
    }
}

public struct ModelIndex<T: Model>: Hashable {
    public var properties: [PartialKeyPath<T>]
    public var isUnique: Bool

    public init(
        properties: [PartialKeyPath<T>],
        isUnique: Bool = false
    ) {
        precondition(!properties.isEmpty)
        self.properties = properties
        self.isUnique = isUnique
    }
}

public protocol Model: Sendable {
    /// Generated by the macro and used internally. You shouldn't have to touch this.
    static var properties: [ModelProperty<Self>] { get }

    /// Placeholder for future use. Not currently used.
    ///
    /// Currently somewhat blocked by <https://github.com/stephencelis/SQLite.swift/issues/1322>.
    static func getIndexes() -> Set<ModelIndex<Self>>

    /// Get the name of the table.
    ///
    /// This function must return the same value each time it is called. The default implementation
    /// returns the type name in snake_case (e.g. on a `struct FooBar`, this would return
    /// `foo_bar`).
    static func getTableName() -> String

    #if !canImport(CoreData)
        /// Generated by the macro and used internally. You shouldn't have to touch this.
        init(row: Row) throws

        /// Generated by the macro and used internally. You shouldn't have to touch this.
        var rowid: Int64 { get set }
    #endif
}

extension Model {
    public static func getIndexes() -> Set<ModelIndex<Self>> { [] }

    public static func getTableName() -> String {
        let typeName = "\(self)"
        let firstLetter = typeName.first?.lowercased() ?? ""
        let rest = typeName.dropFirst().replacing(#/[^A-Za-z0-9_]/#, with: "_")
            .replacing(#/[A-Z]/#, with: { "_" + $0.output.map { $0.lowercased() }.joined() })

        return firstLetter + rest
    }

    static func getColumnName(forKeyPath keyPath: PartialKeyPath<Self>) -> String? {
        properties.first { $0.keyPath == keyPath }?.columnName
    }
}
