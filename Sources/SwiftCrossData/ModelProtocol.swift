public struct ModelProperty<T> {
    public let keyPath: PartialKeyPath<T>
    public let columnName: String
    public let defaultValue: Any?
    
    public init<PropertyType: ColumnType>(
        keyPath: WritableKeyPath<T, PropertyType>,
        columnName: String,
        defaultValue: PropertyType? = nil
    ) {
        self.keyPath = keyPath
        self.columnName = columnName
        self.defaultValue = defaultValue
    }
}

public struct ModelIndex<T> {
    public var properties: [ModelProperty<T>]
    public var isUnique: Bool

    public init(
        properties: [ModelProperty<T>],
        isUnique: Bool = false
    ) {
        self.properties = properties
        self.isUnique = isUnique
    }
}

public protocol Model {
    /// Generated by the macro and used internally. You shouldn't have to touch this.
    static var properties: [ModelProperty<Self>] { get }

    static func getIndexes() -> [ModelIndex<Self>]
    static func getTableName() -> String
}

extension Model {
    public static func getIndexes() -> [ModelIndex<Self>] { [] }

    public static func getTableName() -> String {
        let typeName = "\(self)"
        let firstLetter = typeName.first?.lowercased() ?? ""
        let rest = typeName.dropFirst().replacing(#/[^A-Za-z0-9_]/#, with: "_")
            .replacing(#/[A-Z]/#, with: { "_" + $0.output.map { $0.lowercased() }.joined() })

        return firstLetter + rest
    }

    static func getColumnName(forKeyPath keyPath: PartialKeyPath<Self>) -> String? {
        properties.first { $0.keyPath == keyPath }?.columnName
    }
}
